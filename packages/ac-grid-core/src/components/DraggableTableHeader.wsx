/** @jsxImportSource @wsxjs/wsx-core */

import { LightComponent, state, autoRegister } from "@wsxjs/wsx-core";
import { type Header } from "@tanstack/table-core";
import { flexRender } from "../utils/flex-render";
import {
    draggable,
    dropTargetForElements,
} from "@atlaskit/pragmatic-drag-and-drop/element/adapter";

export interface DraggableTableHeaderProps<TData> {
    /**
     * è¡¨å¤´å¯¹è±¡
     */
    header: Header<TData, unknown>;
    /**
     * æ‹–æ‹½ç»“æŸå›è°ƒ
     */
    onDragEnd?: (activeId: string, overId: string) => void;
}

/**
 * å¯æ‹–æ‹½è¡¨å¤´ç»„ä»¶
 */
@autoRegister({ tagName: "wsx-ac-draggable-table-header" })
export class DraggableTableHeader extends LightComponent {
    // header å’Œ onDragEnd é€šè¿‡ property ä¼ é€’ï¼Œä¸éœ€è¦åœ¨ observedAttributes ä¸­
    // åªæœ‰ç®€å•çš„å­—ç¬¦ä¸²å±æ€§æ‰éœ€è¦ observedAttributes
    static observedAttributes: string[] = [];

    @state private isDragging: boolean = false;
    @state private transform: string = "";

    private cleanupFn: (() => void) | null = null;

    // Property getters/setters
    get header(): Header<any, unknown> {
        return this._header;
    }
    set header(value: Header<any, unknown>) {
        if (value !== this._header) {
            this._header = value;
            if (this.isConnected && value) {
                // å»¶è¿Ÿè®¾ç½®æ‹–æ‹½ï¼Œç¡®ä¿å…ƒç´ å®Œå…¨æ¸²æŸ“
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        if (this.isConnected && this._header) {
                            this.setupDragAndDrop();
                        }
                    });
                });
            }
            // @state å±æ€§å˜åŒ–ä¼šè‡ªåŠ¨è§¦å‘é‡æ–°æ¸²æŸ“ï¼Œä¸éœ€è¦æ‰‹åŠ¨è°ƒç”¨ this.render()
        }
    }
    @state private _header: Header<any, unknown> = null as any;

    get onDragEnd(): ((activeId: string, overId: string) => void) | undefined {
        return this._onDragEnd;
    }
    set onDragEnd(
        value: ((activeId: string, overId: string) => void) | undefined
    ) {
        this._onDragEnd = value;
    }
    private _onDragEnd:
        | ((activeId: string, overId: string) => void)
        | undefined = undefined;

    connectedCallback() {
        super.connectedCallback();

        // ä» property è¯»å– headerï¼ˆwsx ä¼šç›´æ¥è®¾ç½® propertyï¼‰
        const element = this as any;
        if (element.header && !this._header) {
            this.header = element.header;
        }
        if (element.onDragEnd && !this._onDragEnd) {
            this.onDragEnd = element.onDragEnd;
        }

        // å»¶è¿Ÿè®¾ç½®æ‹–æ‹½ï¼Œç¡®ä¿å…ƒç´ å®Œå…¨æ¸²æŸ“
        if (this._header) {
            // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿ DOM å®Œå…¨æ¸²æŸ“
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (this.isConnected && this._header) {
                        this.setupDragAndDrop();
                    }
                });
            });
        }
    }

    onDisconnected() {
        super.onDisconnected?.();
        if (this.cleanupFn) {
            this.cleanupFn();
        }
    }

    private setupDragAndDrop() {
        if (!this._header) return;
        if (!this.isConnected) {
            console.warn(
                "[DraggableTableHeader] setupDragAndDrop called but element not connected"
            );
            return;
        }

        const element = this as unknown as HTMLElement;
        if (!element || !element.getBoundingClientRect) {
            console.warn(
                "[DraggableTableHeader] Invalid element for drag and drop"
            );
            return;
        }

        // éªŒè¯å…ƒç´ åœ¨ DOM ä¸­å¹¶ä¸”æœ‰æœ‰æ•ˆçš„ bounding rect
        try {
            const rect = element.getBoundingClientRect();
            if (!rect || rect.width === 0 || rect.height === 0) {
                console.warn(
                    "[DraggableTableHeader] Element not visible, retrying..."
                );
                // å¦‚æœå…ƒç´ ä¸å¯è§ï¼Œå»¶è¿Ÿé‡è¯•
                setTimeout(() => {
                    if (this.isConnected && this._header) {
                        this.setupDragAndDrop();
                    }
                }, 100);
                return;
            }
        } catch (e) {
            console.warn(
                "[DraggableTableHeader] Error checking element bounds:",
                e
            );
            return;
        }

        const columnId = this._header.column?.id;
        if (!columnId) {
            console.warn("[DraggableTableHeader] No column ID found");
            return;
        }

        try {
            // è®¾ç½®ä¸ºå¯æ‹–æ‹½
            const draggableCleanup = draggable({
                element,
                getInitialData: () => ({ columnId }),
                onDragStart: () => {
                    this.isDragging = true;
                },
                onDrop: () => {
                    this.isDragging = false;
                    this.transform = "";
                },
            });

            // è®¾ç½®ä¸ºå¯æ”¾ç½®ç›®æ ‡
            const dropTargetCleanup = dropTargetForElements({
                element,
                getData: () => ({ columnId }),
                onDrop: ({ source }) => {
                    const activeId = source.data.columnId as string;
                    const overId = columnId;
                    if (activeId && activeId !== overId) {
                        this._onDragEnd?.(activeId, overId);
                    }
                },
            });

            this.cleanupFn = () => {
                draggableCleanup();
                dropTargetCleanup();
            };
        } catch (error) {
            console.error(
                "[DraggableTableHeader] Error setting up drag and drop:",
                error
            );
        }
    }

    render() {
        if (!this._header || !this._header.column) {
            return <th>Loading...</th>;
        }

        // ä½¿ç”¨ getSize() è·å–åˆ—å¤§å°ï¼Œå¦‚æœå¤±è´¥åˆ™ä½¿ç”¨åˆ—å®šä¹‰ä¸­çš„ size æˆ–é»˜è®¤å€¼
        let columnSize = 150;
        try {
            columnSize =
                this._header.column.getSize() ||
                this._header.column.columnDef.size ||
                150;
        } catch (e) {
            // å¦‚æœ getSize() å¤±è´¥ï¼Œä½¿ç”¨åˆ—å®šä¹‰ä¸­çš„ size æˆ–é»˜è®¤å€¼
            columnSize = this._header.column.columnDef.size || 150;
        }
        const style = {
            opacity: this.isDragging ? 0.8 : 1,
            position: "relative" as const,
            transform: this.transform,
            transition: "width transform 0.2s ease-in-out",
            whiteSpace: "nowrap" as const,
            width: `${columnSize}px`,
            zIndex: this.isDragging ? 1 : 0,
        };

        return (
            <th
                colSpan={this._header.colSpan}
                style={style}
                className="px-4 pr-2 py-4 font-medium text-left draggable-header"
            >
                {this._header.isPlaceholder
                    ? null
                    : flexRender(
                          this._header.column.columnDef.header,
                          this._header.getContext()
                      )}
                <button
                    className="drag-handle-button"
                    style={{
                        marginLeft: "8px",
                        cursor: "grab",
                        background: "none",
                        border: "none",
                        padding: "2px",
                    }}
                >
                    ğŸŸ°
                </button>
            </th>
        );
    }
}
