/** @jsxImportSource @wsxjs/wsx-core */
import { LightComponent, state, autoRegister } from "@wsxjs/wsx-core";
import type { Column } from "@tanstack/table-core";
import { type ColumnDef } from "../types/column";

export interface FilterInputProps {
    column: Column<any, unknown>;
    value: string;
    onChange: (value: string) => void;
}

@autoRegister({ tagName: "wsx-ac-filter-input" })
export class FilterInput extends LightComponent {
    get column(): Column<any, unknown> { return this._column; }
    set column(val: Column<any, unknown>) { this._column = val; }
    private _column: Column<any, unknown> = null as any;

    get value(): string { return this._value; }
    set value(val: string) {
        if (val !== this._value) {
            this._value = val;
            this.parseValue(val);
        }
    }
    private _value: string = "";

    get onChange(): ((value: string) => void) | undefined { return this._onChange; }
    set onChange(val: ((value: string) => void) | undefined) { this._onChange = val; }
    private _onChange: ((value: string) => void) | undefined;

    get variant(): "default" | "floating" { return this._variant; }
    set variant(val: "default" | "floating") { this._variant = val; }
    private _variant: "default" | "floating" = "default";

    @state private inputValue: string = "";
    @state private operator: string = "contains";

    onConnected() {
        super.onConnected?.();
        const el = this as any;
        if (el.column) this.column = el.column;
        if (el.value !== undefined) this.value = el.value;
        if (el.onChange) this.onChange = el.onChange;
        if (el.variant) this.variant = el.variant;
    }

    private parseValue(val: string) {
        try {
            if (val && val.startsWith("{")) {
                const parsed = JSON.parse(val);
                this.operator = parsed.operator ?? "contains";
                this.inputValue = parsed.value ?? "";
            } else {
                this.inputValue = val || "";
                const colDef = this._column?.columnDef as ColumnDef<any>;
                const isNumber = colDef?.filterType === "number";
                this.operator = isNumber ? "equals" : "contains";
            }
        } catch {
            this.inputValue = val || "";
            this.operator = "contains";
        }
    }

    private emitChange() {
        const payload = JSON.stringify({
            value: this.inputValue,
            operator: this.operator
        });
        this._onChange?.(payload);
    }

    private handleInput = (e: Event) => {
        this.inputValue = (e.target as HTMLInputElement).value;
        this.emitChange();
    };

    private handleOperatorChange = (e: Event) => {
        this.operator = (e.target as HTMLSelectElement).value;
        this.emitChange();
    };

    render() {
        // Only run parsing if value changed from external source, 
        // effectively handled by the setter of `value` calling parseValue eventually
        // But here we rely on state.
        
        const colDef = this._column?.columnDef as ColumnDef<any>;
        const type = colDef?.filterType === "number" ? "number" : "text";

        if (type === "number") {
            return (
                <div className="filter-input-container">
                    <select
                        className="filter-operator"
                        value={this.operator}
                        onChange={this.handleOperatorChange}
                    >
                        <option value="equals">Equals</option>
                        <option value="greaterThan">Greater than</option>
                        <option value="lessThan">Less than</option>
                    </select>
                    <input
                        type="number"
                        className="filter-input"
                        value={this.inputValue}
                        onInput={this.handleInput}
                        placeholder="Filter number..."
                    />
                </div>
            );
        }

        if (this._variant === "floating") {
            return (
                <div className="filter-input-container floating">
                    <input
                        type={type}
                        className="filter-input floating"
                        value={this.inputValue}
                        onInput={this.handleInput}
                        placeholder="Filter..."
                        disabled={this.operator === 'blank' || this.operator === 'notBlank'}
                    />
                </div>
            );
        }

        return (
            <div className="filter-input-container">
                <select 
                    className="filter-operator"
                    value={this.operator}
                    onChange={this.handleOperatorChange}
                >
                    <option value="contains">Contains</option>
                    <option value="notContains">Not contains</option>
                    <option value="equals">Equals</option>
                    <option value="notEqual">Not equal</option>
                    <option value="startsWith">Starts with</option>
                    <option value="endsWith">Ends with</option>
                    <option value="blank">Blank</option>
                    <option value="notBlank">Not blank</option>
                </select>
                <input
                    type="text"
                    className="filter-input"
                    value={this.inputValue}
                    onInput={this.handleInput}
                    placeholder="Filter..."
                    disabled={this.operator === 'blank' || this.operator === 'notBlank'}
                />
            </div>
        );
    }
}
