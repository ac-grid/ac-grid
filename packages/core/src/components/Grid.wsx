/** @jsxImportSource @wsxjs/wsx-core */

import { LightComponent, state, autoRegister } from "@wsxjs/wsx-core";
import {
    createTable,
    getCoreRowModel,
    getSortedRowModel,
    type Table,
    type ColumnDef,
    type SortingState,
} from "@tanstack/table-core";
import { arrayMove } from "../utils/array-move";
import { flexRender } from "../utils/flex-render";
import "./Grid.css";
import "./DraggableTableHeader.wsx";
import "./DraggableTableRow.wsx";
import "./SortingIndicator.wsx";

export interface GridProps<TData extends { userId?: string }> {
    /**
     * 数据源
     */
    data: TData[];
    /**
     * 列定义
     */
    columns: ColumnDef<TData, any>[];
    /**
     * 自定义类名
     */
    className?: string;
}

/**
 * Grid 组件 - 使用 wsx 和 @tanstack/table-core 实现的数据表格组件
 */
@autoRegister({ tagName: "wsx-ac-grid" })
export class Grid extends LightComponent {
    @state private columnOrder: string[] = [];
    @state private gridData: any[] = [];
    @state private sorting: SortingState = [];

    private table: Table<any> | null = null;

    // Property getters/setters - wsx jsx-factory 会设置这些 properties
    get data(): any[] {
        return this._data;
    }
    set data(value: any[]) {
        if (Array.isArray(value) && value !== this._data) {
            this._data = value;
            this.gridData = [...value];
            this.updateTable();
        }
    }
    @state private _data: any[] = [];

    get columns(): ColumnDef<any, any>[] {
        return this._columns;
    }
    set columns(value: ColumnDef<any, any>[]) {
        if (Array.isArray(value) && value !== this._columns) {
            this._columns = value;
            this.columnOrder = value.map(
                (col, index) => col.id || `col-${index}`
            );
            this.updateTable();
        }
    }
    @state private _columns: ColumnDef<any, any>[] = [];

    get className(): string {
        return this._className;
    }
    set className(value: string) {
        if (value !== this._className) {
            this._className = value;
            // @state 属性变化会自动触发重新渲染
        }
    }
    @state private _className: string = "";

    // Sorting configuration property
    get sortingConfig(): GridSortingConfig | undefined {
        return this._sortingConfigIsSet ? this._sortingConfig : undefined;
    }
    set sortingConfig(value: GridSortingConfig | undefined) {
        if (value === undefined) {
            this._sortingConfigIsSet = false;
            this._sortingConfig = {} as GridSortingConfig;
        } else {
            this._sortingConfigIsSet = true;
            if (value !== this._sortingConfig) {
                this._sortingConfig = value;
                if (value.initialState) {
                    this.sorting = value.initialState;
                }
                this.updateTable();
            }
        }
    }
    @state private _sortingConfigIsSet: boolean = false;
    @state private _sortingConfig: GridSortingConfig = {} as GridSortingConfig;

    onConnected() {
        super.onConnected?.();

        const element = this as any;
        if (
            element.data &&
            Array.isArray(element.data) &&
            element.data.length > 0
        ) {
            this.data = element.data;
        }

        if (
            element.columns &&
            Array.isArray(element.columns) &&
            element.columns.length > 0
        ) {
            this.columns = element.columns;
        }
    }

    /**
     * 更新表格实例
     */
    private updateTable() {
        // 从列定义中提取初始列大小，用于初始化 columnSizing 状态
        // 这是 @tanstack/table-core 的最佳实践：使用列定义中的 size 属性初始化 columnSizing
        // ColumnSizingState = Record<string, number>，键是列 ID，值是大小
        const initialColumnSizing: Record<string, number> = {};
        this._columns.forEach((col) => {
            if (col.id && typeof col.size === "number") {
                initialColumnSizing[col.id] = col.size;
            }
        });

        this.table = createTable({
            data: this.gridData,
            columns: this._columns,
            getCoreRowModel: getCoreRowModel(),
            getSortedRowModel: getSortedRowModel(),
            state: {
                columnOrder: this.columnOrder,
                sorting: this.sorting,
                // 初始化 columnPinning 状态，避免访问 undefined.left 错误
                columnPinning: {
                    left: [],
                    right: [],
                },
                // 初始化 columnSizing 状态，使用列定义中的 size 属性
                columnSizing: initialColumnSizing,
            },
            onColumnOrderChange: (updater) => {
                const newOrder =
                    typeof updater === "function"
                        ? updater(this.columnOrder)
                        : updater;
                this.columnOrder = newOrder;
                this.updateTable();
            },
            onSortingChange: (updater) => {
                const newSorting =
                    typeof updater === "function"
                        ? updater(this.sorting)
                        : updater;
                this.sorting = newSorting;
                this._sortingConfig?.onSortingChange?.(newSorting);
                this.updateTable();
            },
            getRowId: (row) => row.userId || String(Math.random()),
            onStateChange: () => {
                // 表格状态变化时，通过更新 @state 属性来触发重新渲染
                // 或者让 wsx 自动处理渲染
            },
            renderFallbackValue: null,
        });
    }

    /**
     * 处理列拖拽结束
     */
    private handleColumnDragEnd(activeId: string, overId: string) {
        if (activeId !== overId) {
            const oldIndex = this.columnOrder.indexOf(activeId);
            const newIndex = this.columnOrder.indexOf(overId);
            if (oldIndex !== -1 && newIndex !== -1) {
                this.columnOrder = arrayMove(
                    this.columnOrder,
                    oldIndex,
                    newIndex
                );
                this.updateTable();
            }
        }
    }

    /**
     * 处理行拖拽结束
     */
    private handleRowDragEnd(activeId: string, overId: string) {
        if (activeId !== overId) {
            const oldIndex = this.gridData.findIndex(
                (row) => (row.userId || String(Math.random())) === activeId
            );
            const newIndex = this.gridData.findIndex(
                (row) => (row.userId || String(Math.random())) === overId
            );
            if (oldIndex !== -1 && newIndex !== -1) {
                this.gridData = arrayMove(this.gridData, oldIndex, newIndex);
                this.updateTable();
            }
        }
    }

    render() {
        const element = this as any;
        if (
            (!this._data || this._data.length === 0) &&
            element.data &&
            Array.isArray(element.data)
        ) {
            this.data = element.data;
        }
        if (
            (!this._columns || this._columns.length === 0) &&
            element.columns &&
            Array.isArray(element.columns)
        ) {
            this.columns = element.columns;
        }

        if (!this._columns || !this._data || this._columns.length === 0) {
            return <div>Loading...</div>;
        }

        if (!this.table) {
            this.updateTable();
        }

        if (!this.table) {
            return <div>Loading...</div>;
        }

        const headerGroups = this.table.getHeaderGroups();
        const rowModel = this.table.getRowModel();
        const footerGroups = this.table.getFooterGroups();

        // 计算列宽模板 - 固定宽度，不换行
        const columnSizes = headerGroups[0]?.headers
            .filter(h => !h.isPlaceholder)
            .map(h => {
                const size = h.column.getSize() || h.column.columnDef.size || 150;
                return `${size}px`;
            }) || [];
        
        const gridTemplateColumns = columnSizes.length > 0 
            ? columnSizes.join(' ') 
            : 'repeat(7, 150px)';

        return (
            <div 
                className={`ac-grid ${this.className || ""}`}
                style={{
                    '--grid-columns': gridTemplateColumns
                } as any}
            >
                <div className="grid-container">
                    {/* Header */}
                    <div className="grid-header">
                        {headerGroups.map((headerGroup) => (
                            <div key={headerGroup.id} className="grid-header-row">
                                {headerGroup.headers.map((header) => {
                                    if (header.isPlaceholder) {
                                        return null;
                                    }
                                    
                                    const headerContent = flexRender(
                                        header.column.columnDef.header,
                                        header.getContext()
                                    );
                                    
                                    const column = header.column;
                                    const canSort = column.getCanSort();
                                    const sortDirection = column.getIsSorted();
                                    const sortIndex = column.getSortIndex();
                                    
                                    return (
                                        <div
                                            key={header.id}
                                            className={`grid-header-cell ${canSort ? 'sortable' : ''} ${sortDirection ? 'sorting-active' : ''}`}
                                            data-column-id={column.id}
                                            data-can-sort={canSort ? 'true' : 'false'}
                                            style={{
                                                gridColumn: header.colSpan > 1 ? `span ${header.colSpan}` : 'auto',
                                                cursor: canSort ? 'pointer' : 'default'
                                            }}
                                            ref={(el: HTMLElement | null) => {
                                                if (el && canSort) {
                                                    // 移除旧的事件监听器（如果存在）
                                                    const oldHandler = (el as any).__sortHandler;
                                                    if (oldHandler) {
                                                        el.removeEventListener('click', oldHandler);
                                                    }
                                                    
                                                    // 添加新的事件监听器
                                                    const handler = (e: MouseEvent) => {
                                                        // 如果点击的是拖拽按钮，不触发排序
                                                        const target = e.target as HTMLElement;
                                                        if (target.closest('.drag-handle-button')) {
                                                            return;
                                                        }
                                                        
                                                        // 切换排序（Shift 键支持多列排序）
                                                        column.toggleSorting(
                                                            undefined,  // 循环：asc -> desc -> none
                                                            e.shiftKey  // 是否多列排序
                                                        );
                                                    };
                                                    
                                                    el.addEventListener('click', handler);
                                                    (el as any).__sortHandler = handler;
                                                }
                                            }}
                                        >
                                            <div className="header-content">
                                                <span>{headerContent}</span>
                                                <div className="header-actions">
                                                    {canSort && (
                                                        <wsx-ac-sorting-indicator 
                                                            direction={sortDirection}
                                                            index={sortIndex}
                                                        />
                                                    )}
                                                    <button
                                                        className="drag-handle-button"
                                                        type="button"
                                                        aria-label="Drag column to reorder"
                                                        title="Drag to reorder column"
                                                    >
                                                        <svg 
                                                            width="12" 
                                                            height="12" 
                                                            viewBox="0 0 14 14" 
                                                            fill="none" 
                                                            xmlns="http://www.w3.org/2000/svg"
                                                        >
                                                            <path 
                                                                d="M2 3.5h10M2 7h10M2 10.5h10" 
                                                                stroke="currentColor" 
                                                                strokeWidth="1.5" 
                                                                strokeLinecap="round"
                                                                strokeLinejoin="round"
                                                            />
                                                        </svg>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        ))}
                    </div>
                    
                    {/* Body */}
                    <div className="grid-body">
                        {rowModel.rows.map((row) => (
                            <div key={row.id} className="grid-row" data-row-id={row.id}>
                                {row.getVisibleCells().map((cell) => {
                                    const rendered = flexRender(
                                        cell.column.columnDef.cell,
                                        cell.getContext()
                                    );
                                    
                                    return (
                                        <div key={cell.id} className="grid-cell">
                                            <div>{rendered}</div>
                                        </div>
                                    );
                                })}
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        );
    }

    /**
     * 公共 API: 设置排序状态
     */
    public setSorting(sorting: SortingState): void {
        this.sorting = sorting;
        this.updateTable();
    }

    /**
     * 公共 API: 获取当前排序状态
     */
    public getSorting(): SortingState {
        return this.sorting;
    }

    /**
     * 公共 API: 重置排序状态
     */
    public resetSorting(): void {
        this.sorting = [];
        this.updateTable();
    }
}

/**
 * 排序配置接口
 */
export interface GridSortingConfig {
    /**
     * 是否启用排序（默认：true）
     */
    enabled?: boolean;
    /**
     * 是否允许多列排序（默认：true）
     */
    multiColumn?: boolean;
    /**
     * 初始排序状态
     */
    initialState?: SortingState;
    /**
     * 排序状态变化回调
     */
    onSortingChange?: (sorting: SortingState) => void;
}
