/** @jsxImportSource @wsxjs/wsx-core */

import { LightComponent, state, autoRegister } from "@wsxjs/wsx-core";
import {
    createTable,
    getCoreRowModel,
    getSortedRowModel,
    getFilteredRowModel,
    getExpandedRowModel,
    getGroupedRowModel,
    getPaginationRowModel,
    type Table,
    type SortingState,
    type PaginationState,
    type RowSelectionState,
    type ColumnPinningState,
} from "@tanstack/table-core";
import { type ColumnDef } from "../types/column";
import { arrayMove } from "../utils/array-move";
import { flexRender } from "../utils/flex-render";
import type { FilterState, GridFilteringConfig } from "../types/filtering";
import type { GridResizingConfig } from "../types/resizing";
import type { GridVirtualizationConfig, VirtualizerState } from "../types/virtualization";
import type { GridPaginationConfig } from "../types/pagination";
import type { GridSelectionConfig } from "../types/selection";
import type { GridPinningConfig } from "../types/pinning";
import type { GridEditingConfig } from "../types/editing";
import type { GridGroupingConfig } from "../types/grouping";
import { Virtualizer } from "../utils/virtualizer";
import {
    defaultTextFilter,
    numberFilter,
    dateFilter,
} from "../utils/filter-functions";
import "./Grid.css";
import "./DraggableTableHeader.wsx";
import "./DraggableTableRow.wsx";
import "./SortingIndicator.wsx";
import "./FilterIcon.wsx";
import "./FilterMenu.wsx";

/** 默认列宽信息，保证 table.getState().columnSizingInfo 永不为 undefined，避免 "reading 'isResizingColumn'" 报错 */
const DEFAULT_COLUMN_SIZING_INFO = {
    startOffset: null as number | null,
    startSize: null as number | null,
    deltaOffset: null as number | null,
    deltaPercentage: null as number | null,
    isResizingColumn: false as false | string,
    columnSizingStart: [] as [string, number][],
};

export interface GridProps<TData extends { userId?: string }> {
    /**
     * 数据源
     */
    data: TData[];
    /**
     * 列定义
     */
    columns: ColumnDef<TData, any>[];
    /**
     * 自定义类名
     */
    className?: string;
}

/**
 * Grid 组件 - 使用 wsx 和 @tanstack/table-core 实现的数据表格组件
 */
@autoRegister({ tagName: "wsx-ac-grid" })
export class Grid extends LightComponent {
    @state private columnOrder: string[] = [];
    @state private gridData: any[] = [];
    @state private sorting: SortingState = [];
    @state private columnFilters: Record<string, string> = {};
    @state private globalFilter: string = "";
    
    get openFilterMenu(): string | null { return this._openFilterMenu; }
    set openFilterMenu(val: string | null) {
        if (this._openFilterMenu !== val) {
            this._openFilterMenu = val;
            // Update portal when state changes
            this.updateFilterMenuPortal();
        }
    }
    @state private _openFilterMenu: string | null = null;
    
    @state private filterMenuPosition: { x: number; y: number } = { x: 0, y: 0 };
    private activeFilterColumn: any = null;

    private get columnFiltersArray(): Array<{ id: string; value: unknown }> {
        return Object.entries(this.columnFilters).map(([id, value]) => ({
            id,
            value,
        }));
    }

    private table: Table<any> | null = null;
    private headerScrollElement: HTMLElement | null = null;
    private bodyScrollElement: HTMLElement | null = null;
    private isSyncingScroll: boolean = false;

    // Property getters/setters - wsx jsx-factory 会设置这些 properties
    get data(): any[] {
        return this._data;
    }
    set data(value: any[]) {
        if (Array.isArray(value) && value !== this._data) {
            this._data = value;
            this.gridData = [...value];
            this.updateTable();
        }
    }
    @state private _data: any[] = [];

    get columns(): ColumnDef<any, any>[] {
        return this._columns;
    }
    set columns(value: ColumnDef<any, any>[]) {
        if (Array.isArray(value) && value !== this._columns) {
            this._columns = value;
            this.columnOrder = value.map(
                (col, index) => col.id || `col-${index}`,
            );
            this.updateTable();
        }
    }
    @state private _columns: ColumnDef<any, any>[] = [];

    get className(): string {
        return this._className;
    }
    set className(value: string) {
        if (value !== this._className) {
            this._className = value;
            // @state 属性变化会自动触发重新渲染
        }
    }
    @state private _className: string = "";

    // Sorting configuration property
    get sortingConfig(): GridSortingConfig | undefined {
        return this._sortingConfigIsSet ? this._sortingConfig : undefined;
    }
    set sortingConfig(value: GridSortingConfig | undefined) {
        if (value === undefined) {
            this._sortingConfigIsSet = false;
            this._sortingConfig = {} as GridSortingConfig;
        } else {
            this._sortingConfigIsSet = true;
            if (value !== this._sortingConfig) {
                this._sortingConfig = value;
                if (value.initialState) {
                    this.sorting = value.initialState;
                }
                this.updateTable();
            }
        }
    }
    @state private _sortingConfigIsSet: boolean = false;
    @state private _sortingConfig: GridSortingConfig = {} as GridSortingConfig;

    get filteringConfig(): GridFilteringConfig | undefined {
        return this._filteringConfigIsSet ? this._filteringConfig : undefined;
    }
    set filteringConfig(value: GridFilteringConfig | undefined) {
        if (value === undefined) {
            this._filteringConfigIsSet = false;
            this._filteringConfig = {} as GridFilteringConfig;
        } else {
            this._filteringConfigIsSet = true;
            if (value !== this._filteringConfig) {
                this._filteringConfig = value;
                if (value.initialGlobalFilter !== undefined) {
                    this.globalFilter = value.initialGlobalFilter;
                }
                if (value.initialColumnFilters) {
                    this.columnFilters = { ...value.initialColumnFilters };
                }
                this.updateTable();
            }
        }
    }
    @state private _filteringConfigIsSet: boolean = false;
    @state private _filteringConfig: GridFilteringConfig =
        {} as GridFilteringConfig;

    // Resizing configuration property
    get resizingConfig(): GridResizingConfig | undefined {
        return this._resizingConfigIsSet ? this._resizingConfig : undefined;
    }
    set resizingConfig(value: GridResizingConfig | undefined) {
        if (value === undefined) {
            this._resizingConfigIsSet = false;
            this._resizingConfig = {} as GridResizingConfig;
        } else {
            this._resizingConfigIsSet = true;
            if (value !== this._resizingConfig) {
                this._resizingConfig = value;
                if (value.initialColumnSizing) {
                    this.columnSizing = value.initialColumnSizing;
                }
                this.updateTable();
            }
        }
    }
    @state private _resizingConfigIsSet: boolean = false;
    @state private _resizingConfig: GridResizingConfig = {} as GridResizingConfig;
    @state private columnSizing: Record<string, number> = {};
    @state private columnSizingInfo = { ...DEFAULT_COLUMN_SIZING_INFO };

    // Virtualization configuration
    get virtualizationConfig(): GridVirtualizationConfig | undefined {
        return this._virtualizationConfigIsSet ? this._virtualizationConfig : undefined;
    }
    set virtualizationConfig(value: GridVirtualizationConfig | undefined) {
        if (value === undefined) {
            this._virtualizationConfigIsSet = false;
            this._virtualizationConfig = {} as GridVirtualizationConfig;
        } else {
            this._virtualizationConfigIsSet = true;
            if (value !== this._virtualizationConfig) {
                this._virtualizationConfig = value;
                this.virtualizer.updateConfig(value);
                this.updateVirtualization();
            }
        }
    }
    @state private _virtualizationConfigIsSet: boolean = false;
    @state private _virtualizationConfig: GridVirtualizationConfig = {} as GridVirtualizationConfig;
    @state private virtualState: VirtualizerState = {
        scrollTop: 0,
        containerHeight: 0,
        totalHeight: 0,
        visibleRange: { start: 0, end: 0 }
    };

    // Pagination config
    get paginationConfig(): GridPaginationConfig | undefined {
        return this._paginationConfigIsSet ? this._paginationConfig : undefined;
    }
    set paginationConfig(value: GridPaginationConfig | undefined) {
        if (value === undefined) {
            this._paginationConfigIsSet = false;
            this._paginationConfig = {} as GridPaginationConfig;
        } else {
            this._paginationConfigIsSet = true;
            if (value !== this._paginationConfig) {
                this._paginationConfig = value;
                if (value.initialPageIndex !== undefined || value.pageSize !== undefined) {
                    this.pagination = {
                        pageIndex: value.initialPageIndex || 0,
                        pageSize: value.pageSize || 10,
                    };
                }
                this.updateTable();
            }
        }
    }
    @state private _paginationConfigIsSet: boolean = false;
    @state private _paginationConfig: GridPaginationConfig = {} as GridPaginationConfig;
    @state private pagination: PaginationState = { pageIndex: 0, pageSize: 10 };

    // Selection config
    get selectionConfig(): GridSelectionConfig | undefined {
        return this._selectionConfigIsSet ? this._selectionConfig : undefined;
    }
    set selectionConfig(value: GridSelectionConfig | undefined) {
        if (value === undefined) {
            this._selectionConfigIsSet = false;
            this._selectionConfig = {} as GridSelectionConfig;
        } else {
            this._selectionConfigIsSet = true;
            if (value !== this._selectionConfig) {
                this._selectionConfig = value;
                if (value.initialRowSelection) {
                    this.rowSelection = value.initialRowSelection;
                }
                this.updateTable();
            }
        }
    }
    @state private _selectionConfigIsSet: boolean = false;
    @state private _selectionConfig: GridSelectionConfig = {} as GridSelectionConfig;
    @state private rowSelection: RowSelectionState = {};

    // Pinning config
    get pinningConfig(): GridPinningConfig | undefined {
        return this._pinningConfigIsSet ? this._pinningConfig : undefined;
    }
    set pinningConfig(value: GridPinningConfig | undefined) {
        if (value === undefined) {
            this._pinningConfigIsSet = false;
            this._pinningConfig = {} as GridPinningConfig;
        } else {
            this._pinningConfigIsSet = true;
            if (value !== this._pinningConfig) {
                this._pinningConfig = value;
                if (value.initialState) {
                    this.columnPinning = value.initialState;
                }
                this.updateTable();
            }
        }
    }
    @state private _pinningConfigIsSet: boolean = false;
    @state private _pinningConfig: GridPinningConfig = {} as GridPinningConfig;
    @state private columnPinning: ColumnPinningState = { left: [], right: [] };

    // Editing config
    get editingConfig(): GridEditingConfig | undefined {
        return this._editingConfigIsSet ? this._editingConfig : undefined;
    }
    set editingConfig(value: GridEditingConfig | undefined) {
        if (value === undefined) {
            this._editingConfigIsSet = false;
            this._editingConfig = {} as GridEditingConfig;
        } else {
            this._editingConfigIsSet = true;
            if (value !== this._editingConfig) {
                this._editingConfig = value;
                this.updateTable();
            }
        }
    }
    @state private _editingConfigIsSet: boolean = false;
    @state private _editingConfig: GridEditingConfig = {} as GridEditingConfig;
    @state private editingState: { rowId: string | null; columnId: string | null; value: any } = { rowId: null, columnId: null, value: null };

    // Grouping config
    get groupingConfig(): GridGroupingConfig | undefined {
        return this._groupingConfigIsSet ? this._groupingConfig : undefined;
    }
    set groupingConfig(value: GridGroupingConfig | undefined) {
        if (value === undefined) {
            this._groupingConfigIsSet = false;
            this._groupingConfig = {} as GridGroupingConfig;
        } else {
            this._groupingConfigIsSet = true;
            if (value !== this._groupingConfig) {
                this._groupingConfig = value;
                if (value.initialGrouping) {
                    this.grouping = value.initialGrouping;
                }
                if (value.initialExpanded) {
                    this.expanded = value.initialExpanded === true ? true : (value.initialExpanded || {});
                }
                this.updateTable();
            }
        }
    }
    @state private _groupingConfigIsSet: boolean = false;
    @state private _groupingConfig: GridGroupingConfig = {} as GridGroupingConfig;
    @state private grouping: string[] = [];
    @state private expanded: Record<string, boolean> | boolean = {};

    private virtualizer: Virtualizer = new Virtualizer({});

    /** RFC-0003: 外部搜索框等可只调 setGlobalFilter，无需传 filteringConfig 即启用过滤 */
    get enableFiltering(): boolean {
        return this._enableFiltering;
    }
    set enableFiltering(value: boolean) {
        if (value !== this._enableFiltering) {
            this._enableFiltering = Boolean(value);
            this.updateTable();
        }
    }
    @state private _enableFiltering: boolean = false;

    get enableFloatingFilter(): boolean {
        return this._enableFloatingFilter;
    }
    set enableFloatingFilter(value: boolean) {
        if (value !== this._enableFloatingFilter) {
            this._enableFloatingFilter = Boolean(value);
            this.updateTable();
        }
    }
    @state private _enableFloatingFilter: boolean = false;

    private get isFilteringEnabled(): boolean {
        const hasFilterState =
            this.globalFilter !== "" ||
            Object.keys(this.columnFilters).length > 0;
        const configEnables =
            this._filteringConfigIsSet &&
            this._filteringConfig?.enabled !== false;
        if (
            this._filteringConfigIsSet &&
            this._filteringConfig?.enabled === false
        ) {
            return false;
        }
        return configEnables || this._enableFiltering || hasFilterState;
    }

    onConnected() {
        super.onConnected?.();

        // Initialize virtualizer
        this.virtualizer = new Virtualizer(this._virtualizationConfig);

        const element = this as any;
        if (
            element.data &&
            Array.isArray(element.data) &&
            element.data.length > 0
        ) {
            this.data = element.data;
        }

        if (
            element.columns &&
            Array.isArray(element.columns) &&
            element.columns.length > 0
        ) {
            this.columns = element.columns;
        }
    }

    // Pagination Methods
    public setPageIndex(pageIndex: number) {
        this.pagination = { ...this.pagination, pageIndex };
        this.updateTable();
    }

    public setPageSize(pageSize: number) {
        this.pagination = { ...this.pagination, pageSize, pageIndex: 0 };
        this.updateTable();
    }

    // Selection Methods
    public selectRow(rowId: string) {
        this.rowSelection = { ...this.rowSelection, [rowId]: true };
        this.notifySelectionChange();
        this.updateTable();
    }

    public deselectRow(rowId: string) {
        const next = { ...this.rowSelection };
        delete next[rowId];
        this.rowSelection = next;
        this.notifySelectionChange();
        this.updateTable();
    }

    public toggleRowSelection(rowId: string) {
        if (this.rowSelection[rowId]) {
            this.deselectRow(rowId);
        } else {
            this.selectRow(rowId);
        }
    }

    public selectAll() {
        if (!this.table) return;
        const newSelection: RowSelectionState = {};
        const rowModel = this.table.getRowModel();
        const rows = rowModel && rowModel.rows ? rowModel.rows : [];
        rows.forEach(row => {
            newSelection[row.id] = true;
        });
        this.rowSelection = newSelection;
        this.notifySelectionChange();
        this.updateTable();
    }

    public deselectAll() {
        this.rowSelection = {};
        this.notifySelectionChange();
        this.updateTable();
    }

    public getSelectedRows() {
        const sel = this.table?.getSelectedRowModel();
        return sel && sel.rows ? sel.rows : [];
    }

    public getSelectedRowIds() {
        return Object.keys(this.rowSelection);
    }

    private notifySelectionChange() {
        this._selectionConfig?.onRowSelectionChange?.(this.rowSelection);
    }

    private handleScroll = (e: Event) => {
        if (!this._virtualizationConfig.enabled) {
            this.syncHeaderScroll();
            return;
        }
        
        const target = e.target as HTMLElement;
        // Sync header scroll
        if (this.headerScrollElement) {
            this.headerScrollElement.scrollLeft = target.scrollLeft;
        }

        // Update virtual state
        requestAnimationFrame(() => {
            const rm = this.table?.getRowModel();
            const rowCount = rm && rm.rows ? rm.rows.length : 0;
            this.virtualizer.updateState(
                target.scrollTop,
                target.clientHeight,
                rowCount
            );
            this.virtualState = this.virtualizer.getVirtualState();
        });
    };

    private filterMenuContainer: HTMLElement | null = null;

    private updateFilterMenuPortal() {
        if (this.openFilterMenu && this.activeFilterColumn) {
            if (!this.filterMenuContainer) {
                this.filterMenuContainer = document.createElement("div");
                this.filterMenuContainer.className = "ac-grid-filter-menu-portal";
                document.body.appendChild(this.filterMenuContainer);
                
                const closeHandler = (e: MouseEvent) => {
                    if (this.filterMenuContainer && !this.filterMenuContainer.contains(e.target as Node)) {
                         this.openFilterMenu = null;
                         this.activeFilterColumn = null;
                         this.updateFilterMenuPortal();
                         document.removeEventListener('click', closeHandler);
                    }
                };
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            }

            this.filterMenuContainer.innerHTML = '';
            
            const menu = document.createElement('wsx-ac-filter-menu') as any;
            menu.column = this.activeFilterColumn;
            menu.value = this.columnFilters[this.activeFilterColumn.id] ?? "";
            
            menu.onChange = (val: string) => {
                this.setColumnFilter(this.activeFilterColumn.id, val);
            };
            menu.onClose = () => {
                this.openFilterMenu = null;
                this.activeFilterColumn = null;
                this.updateFilterMenuPortal();
            };
            
            const { x, y } = this.filterMenuPosition;
            this.filterMenuContainer.style.position = 'absolute';
            this.filterMenuContainer.style.top = `${y}px`;
            this.filterMenuContainer.style.left = `${x}px`;
            this.filterMenuContainer.style.zIndex = '99999';
            
            this.filterMenuContainer.appendChild(menu);
            
        } else {
            if (this.filterMenuContainer) {
                if (this.filterMenuContainer.parentNode) {
                    this.filterMenuContainer.parentNode.removeChild(this.filterMenuContainer);
                }
                this.filterMenuContainer = null;
            }
        }
    }

    private updateVirtualization() {
        if (this.bodyScrollElement && this.table) {
            const rm = this.table.getRowModel();
            const rowCount = rm && rm.rows ? rm.rows.length : 0;
            this.virtualizer.updateState(
                this.bodyScrollElement.scrollTop,
                this.bodyScrollElement.clientHeight,
                rowCount
            );
            this.virtualState = this.virtualizer.getVirtualState();
        }
    }

    /**
     * 更新表格实例
     */
    private updateTable() {
        const defaultColumnSizing: Record<string, number> = {};
        this._columns.forEach((col) => {
            const colId = col.id ?? (col as { accessorKey?: string }).accessorKey ?? "";
            if (colId && typeof col.size === "number") {
                defaultColumnSizing[colId] = col.size;
            }
        });

        const currentColumnSizing = {
            ...defaultColumnSizing,
            ...this.columnSizing,
        };

        const isFilteringEnabled = this.isFilteringEnabled;
        const isResizingEnabled = this._resizingConfigIsSet ? this._resizingConfig?.enabled !== false : false;
        const isPaginationEnabled = this._paginationConfigIsSet ? this._paginationConfig?.enabled !== false : false;
        const isSelectionEnabled = this._selectionConfigIsSet ? this._selectionConfig?.enabled !== false : false;
        const isEditingEnabled = this._editingConfigIsSet ? this._editingConfig?.enabled !== false : false;
        const isGroupingEnabled = this._groupingConfigIsSet ? this._groupingConfig?.enabled !== false : false;

        // Add selection column if enabled
        let tableColumns = this._columns;
        if (isSelectionEnabled && this._selectionConfig?.enableCheckbox !== false && this._selectionConfig?.mode !== 'single') {
            const selectionCol: ColumnDef<any, any> = {
                id: 'selection',
                header: ({ table }) => (
                    <wsx-ac-selection-checkbox
                        checked={table.getIsAllRowsSelected()}
                        indeterminate={table.getIsSomeRowsSelected()}
                        onChange={table.getToggleAllRowsSelectedHandler()}
                    />
                ),
                cell: ({ row }) => (
                    <wsx-ac-selection-checkbox
                        checked={row.getIsSelected()}
                        indeterminate={row.getIsSomeSelected()}
                        onChange={row.getToggleSelectedHandler()}
                    />
                ),
                size: 40,
                enableColumnFilter: false,
                enableResizing: false,
                enableSorting: false,
            };
            // Check if selection column already exists to avoid duplicates or issues
            if (!tableColumns.find(c => c.id === 'selection')) {
                tableColumns = [selectionCol, ...tableColumns];
            }
        }

        const columnsWithFilters = tableColumns.map((col) => {
            if (!isFilteringEnabled) return col;
            if (col.enableColumnFilter === false) return col;
            if (col.filterFn) return col;
            const filterType = col.filterType ?? "text";
            const defaultFilterFn =
                filterType === "number"
                    ? numberFilter
                    : filterType === "date"
                      ? dateFilter
                      : defaultTextFilter;
            return { ...col, filterFn: defaultFilterFn };
        });

        this.table = createTable({
            data: this.gridData,
            columns: columnsWithFilters,
            getCoreRowModel: getCoreRowModel(),
            getSortedRowModel: getSortedRowModel(),
            ...(isGroupingEnabled && {
                getGroupedRowModel: getGroupedRowModel(),
                getExpandedRowModel: getExpandedRowModel(),
            }),
            ...(isPaginationEnabled && {
                getPaginationRowModel: getPaginationRowModel(),
            }),
            ...(isFilteringEnabled && {
                getFilteredRowModel: getFilteredRowModel(),
                globalFilterFn: (row, _columnId, filterValue) => {
                    if (!filterValue || String(filterValue).trim() === "")
                        return true;
                    const searchValue = String(filterValue).toLowerCase();
                    return columnsWithFilters.some((col) => {
                        if (col.enableColumnFilter === false) return false;
                        const columnId =
                            col.id ??
                            (col as { accessorKey?: string }).accessorKey;
                        if (!columnId) return false;
                        const value = row.getValue(columnId as string);
                        if (value == null) return false;
                        return String(value)
                            .toLowerCase()
                            .includes(searchValue);
                    });
                },
            }),
            state: {
                columnOrder: this.columnOrder,
                sorting: this.sorting,
                ...(isFilteringEnabled && {
                    columnFilters: this.columnFiltersArray,
                    globalFilter: this.globalFilter,
                }),
                ...(isGroupingEnabled && {
                    grouping: this.grouping,
                    expanded: this.expanded === false ? {} : this.expanded,
                }),
                columnPinning: { left: [], right: [] },
                columnSizing: currentColumnSizing,
                columnSizingInfo: this.columnSizingInfo ?? DEFAULT_COLUMN_SIZING_INFO,
                pagination: this.pagination,
                rowSelection: this.rowSelection,
            },
            ...(isResizingEnabled && {
                enableColumnResizing: true,
                columnResizeMode: "onChange",
                onColumnSizingChange: (updater: any) => {
                    const newSizing =
                        typeof updater === "function"
                            ? updater(this.columnSizing || {})
                            : updater;
                    this.columnSizing = newSizing;
                    this._resizingConfig?.onColumnSizingChange?.(newSizing);
                    this.updateTable();
                },
                onColumnSizingInfoChange: (updater: any) => {
                    const prev = this.columnSizingInfo ?? DEFAULT_COLUMN_SIZING_INFO;
                    const newInfo =
                        typeof updater === "function"
                            ? updater(prev)
                            : updater;
                    this.columnSizingInfo = newInfo ?? prev;
                    this.updateTable();
                },
            }),
            ...(isGroupingEnabled && {
                onExpandedChange: (updater: any) => {
                    const newExpanded = typeof updater === "function" ? updater(this.expanded) : updater;
                    this.expanded = newExpanded;
                    this._groupingConfig?.onExpandedChange?.(newExpanded);
                    this.updateTable();
                }
            }),
            ...(isPaginationEnabled && {
                onPaginationChange: (updater: any) => {
                    const newPagination = typeof updater === "function" ? updater(this.pagination) : updater;
                    this.pagination = newPagination;
                    this._paginationConfig?.onPaginationChange?.(newPagination);
                    this.updateTable();
                }
            }),
            ...(isSelectionEnabled && {
                enableRowSelection: true,
                enableMultiRowSelection: this._selectionConfig?.mode === 'multiple',
                onRowSelectionChange: (updater: any) => {
                    const newSelection = typeof updater === "function" ? updater(this.rowSelection) : updater;
                    this.rowSelection = newSelection;
                    this.notifySelectionChange();
                    this.updateTable();
                }
            }),
            onColumnOrderChange: (updater) => {
                const newOrder =
                    typeof updater === "function"
                        ? updater(this.columnOrder)
                        : updater;
                this.columnOrder = newOrder;
                this.updateTable();
            },
            onSortingChange: (updater) => {
                const newSorting =
                    typeof updater === "function"
                        ? updater(this.sorting)
                        : updater;
                this.sorting = newSorting;
                this._sortingConfig?.onSortingChange?.(newSorting);
                this.updateTable();
                this.updateVirtualization();
            },
            onGroupingChange: (updater) => {
                const newGrouping = typeof updater === "function" ? updater(this.grouping) : updater;
                this.grouping = newGrouping;
                this._groupingConfig?.onGroupingChange?.(newGrouping);
                this.updateTable();
            },
            ...(isFilteringEnabled && {
                onColumnFiltersChange: (updater) => {
                    const currentArray = this.columnFiltersArray;
                    const newArray =
                        typeof updater === "function"
                            ? updater(currentArray)
                            : currentArray;
                    const record: Record<string, string> = {};
                    if (Array.isArray(newArray)) {
                        newArray.forEach((f) => {
                            if (f?.id != null && f?.value != null) {
                                const s = String(f.value).trim();
                                if (s !== "") record[f.id] = s;
                            }
                        });
                    }
                    this.columnFilters = record;
                    this.notifyFilterChange();
                    this.updateTable();
                    this.updateVirtualization();
                },
                onGlobalFilterChange: (updater) => {
                    this.globalFilter =
                        typeof updater === "function"
                            ? updater(this.globalFilter)
                            : String(updater ?? "");
                    this.notifyFilterChange();
                    this.updateTable();
                    this.updateVirtualization();
                },
            }),
            getRowId: (row) => row.userId || String(Math.random()),
            onStateChange: () => {},
            renderFallbackValue: null,
        });
    }

    /**
     * 处理列拖拽结束
     */
    private handleColumnDragEnd(activeId: string, overId: string) {
        if (activeId !== overId) {
            const oldIndex = this.columnOrder.indexOf(activeId);
            const newIndex = this.columnOrder.indexOf(overId);
            if (oldIndex !== -1 && newIndex !== -1) {
                this.columnOrder = arrayMove(
                    this.columnOrder,
                    oldIndex,
                    newIndex,
                );
                this.updateTable();
            }
        }
    }

    /**
     * 处理行拖拽结束
     */
    private handleRowDragEnd(activeId: string, overId: string) {
        if (activeId !== overId) {
            const oldIndex = this.gridData.findIndex(
                (row) => (row.userId || String(Math.random())) === activeId,
            );
            const newIndex = this.gridData.findIndex(
                (row) => (row.userId || String(Math.random())) === overId,
            );
            if (oldIndex !== -1 && newIndex !== -1) {
                this.gridData = arrayMove(this.gridData, oldIndex, newIndex);
                this.updateTable();
            }
        }
    }

    render() {
        const element = this as any;
        if (
            (!this._data || this._data.length === 0) &&
            element.data &&
            Array.isArray(element.data)
        ) {
            this.data = element.data;
        }
        if (
            (!this._columns || this._columns.length === 0) &&
            element.columns &&
            Array.isArray(element.columns)
        ) {
            this.columns = element.columns;
        }

        if (!this._columns || !this._data || this._columns.length === 0) {
            return <div>Loading...</div>;
        }

        if (!this.table) {
            this.updateTable();
        }

        if (!this.table) {
            return <div>Loading...</div>;
        }

        const headerGroups = this.table.getHeaderGroups();
        const rowModel = this.table.getRowModel();
        const allRows = rowModel && rowModel.rows ? rowModel.rows : [];
        let visibleRows = allRows;
        let paddingTop = 0;
        let paddingBottom = 0;

        if (this._virtualizationConfig.enabled && this.virtualState.totalHeight > 0) {
            const { start, end } = this.virtualState.visibleRange;
            visibleRows = allRows.slice(start, end);
            const rowHeight = this._virtualizationConfig.rowHeight || 35;
            paddingTop = start * rowHeight;
            paddingBottom = Math.max(0, (allRows.length - end) * rowHeight);
        }

        // 计算列宽模板 - 固定宽度，不换行
        const columnSizes =
            headerGroups[0]?.headers
                .filter((h) => !h.isPlaceholder)
                .map((h) => {
                    const size =
                        h.column.getSize() || h.column.columnDef.size || 150;
                    return `${size}px`;
                }) || [];

        const gridTemplateColumns =
            columnSizes.length > 0 ? columnSizes.join(" ") : "repeat(7, 150px)";

        return (
            <div
                className={`ac-grid ${this.className || ""}`}
                style={
                    {
                        "--grid-columns": gridTemplateColumns,
                    } as any
                }
            >
                <div className="grid-container">
                    {/* Header */}
                    <div
                        className="grid-header"
                        ref={(el: HTMLElement | null) => {
                            if (el) {
                                this.headerScrollElement = el;
                                this.syncHeaderScroll();
                            }
                        }}
                    >
                        {headerGroups.map((headerGroup) => (
                            <div
                                key={headerGroup.id}
                                className="grid-header-row"
                            >
                                {headerGroup.headers.map((header) => {
                                    if (header.isPlaceholder) {
                                        return null;
                                    }

                                    const headerContent = flexRender(
                                        header.column.columnDef.header,
                                        header.getContext(),
                                    );

                                    const column = header.column;
                                    const canSort = column.getCanSort();
                                    const sortDirection = column.getIsSorted();
                                    const sortIndex = column.getSortIndex();
                                    const canResize = column.getCanResize();
                                    const isResizing = column.getIsResizing();

                                    const canFilter =
                                        this.isFilteringEnabled &&
                                        (column.columnDef as { enableColumnFilter?: boolean })
                                            .enableColumnFilter !== false;
                                    const hasFilter =
                                        canFilter &&
                                        this.columnFilters[column.id] &&
                                        this.columnFilters[column.id] !== "";
                                    const isFilterMenuOpen =
                                        this.openFilterMenu === column.id;
                                    const filterValue =
                                        this.columnFilters[column.id] ?? "";
                                    
                                    const isPinnedLeft = column.getIsPinned() === 'left';
                                    const isPinnedRight = column.getIsPinned() === 'right';
                                    
                                    // Dynamic zIndex: active filter menu raises the header cell
                                    const activeZIndex = isFilterMenuOpen ? 100 : undefined;
                                    
                                    const pinnedStyle = isPinnedLeft 
                                        ? { left: `${column.getStart("left")}px`, position: 'sticky' as const, zIndex: activeZIndex || 3 }
                                        : isPinnedRight
                                            ? { right: `${column.getAfter("right")}px`, position: 'sticky' as const, zIndex: activeZIndex || 3 }
                                            : (activeZIndex ? { zIndex: activeZIndex } : {});

                                    return (
                                        <div
                                            key={header.id}
                                            className={`grid-header-cell ${canSort ? "sortable" : ""} ${sortDirection ? "sorting-active" : ""}`}
                                            data-column-id={column.id}
                                            data-pinned={column.getIsPinned() || undefined}
                                            data-can-sort={
                                                canSort ? "true" : "false"
                                            }
                                            style={{
                                                gridColumn:
                                                    header.colSpan > 1
                                                        ? `span ${header.colSpan}`
                                                        : "auto",
                                                cursor: canSort
                                                    ? "pointer"
                                                    : "default",
                                                position: "relative" as const,
                                                ...pinnedStyle,
                                            }}
                                            ref={(el: HTMLElement | null) => {
                                                if (el && canSort) {
                                                    // 移除旧的事件监听器（如果存在）
                                                    const oldHandler = (
                                                        el as any
                                                    ).__sortHandler;
                                                    if (oldHandler) {
                                                        el.removeEventListener(
                                                            "click",
                                                            oldHandler,
                                                        );
                                                    }

                                                    // 添加新的事件监听器
                                                    const handler = (
                                                        e: MouseEvent,
                                                    ) => {
                                                        // 如果点击的是拖拽按钮，不触发排序
                                                        const target =
                                                            e.target as HTMLElement;
                                                        if (
                                                            target.closest(
                                                                ".drag-handle-button",
                                                            ) ||
                                                            target.closest(
                                                                "wsx-ac-filter-icon",
                                                            )
                                                        ) {
                                                            return;
                                                        }
                                                        column.toggleSorting(
                                                            undefined, // 循环：asc -> desc -> none
                                                            e.shiftKey, // 是否多列排序
                                                        );
                                                    };

                                                    el.addEventListener(
                                                        "click",
                                                        handler,
                                                    );
                                                    (el as any).__sortHandler =
                                                        handler;
                                                }
                                            }}
                                        >
                                            <div className="header-content">
                                                <span>{headerContent}</span>
                                                <div className="header-actions">
                                                    {canFilter && (
                                                        <span
                                                            onClick={(e: MouseEvent) => {
                                                                e.stopPropagation();
                                                                if (this.openFilterMenu === column.id) {
                                                                    this.activeFilterColumn = null;
                                                                    this.openFilterMenu = null;
                                                                } else {
                                                                    const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
                                                                    this.filterMenuPosition = {
                                                                        x: rect.left + window.scrollX,
                                                                        y: rect.bottom + window.scrollY
                                                                    };
                                                                    this.activeFilterColumn = column;
                                                                    this.openFilterMenu = column.id;
                                                                }
                                                            }}
                                                            style={{ cursor: "pointer" }}
                                                        >
                                                            <wsx-ac-filter-icon
                                                                active={hasFilter}
                                                                visible={true}
                                                            />
                                                        </span>
                                                    )}
                                                    {canSort && (
                                                        <wsx-ac-sorting-indicator
                                                            direction={
                                                                sortDirection
                                                            }
                                                            index={sortIndex}
                                                        />
                                                    )}
                                                    <button
                                                        className="drag-handle-button"
                                                        type="button"
                                                        aria-label="Drag column to reorder"
                                                        title="Drag to reorder column"
                                                    >
                                                        <svg
                                                            width="12"
                                                            height="12"
                                                            viewBox="0 0 14 14"
                                                            fill="none"
                                                            xmlns="http://www.w3.org/2000/svg"
                                                        >
                                                            <path
                                                                d="M2 3.5h10M2 7h10M2 10.5h10"
                                                                stroke="currentColor"
                                                                strokeWidth="1.5"
                                                                strokeLinecap="round"
                                                                strokeLinejoin="round"
                                                            />
                                                        </svg>
                                                    </button>
                                                </div>
                                            </div>
                                            {canResize && (
                                                <div
                                                    className={`resizer ${isResizing ? "isResizing" : ""}`}
                                                    onMouseDown={header.getResizeHandler()}
                                                    onTouchStart={header.getResizeHandler()}
                                                    onClick={(e) => e.stopPropagation()}
                                                />
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        ))}
                        {this.isFilteringEnabled && this.enableFloatingFilter && headerGroups.length > 0 && (
                            <div className="grid-header-row floating-filter-row">
                                {headerGroups[headerGroups.length - 1].headers.map((header) => {
                                    if (header.isPlaceholder) {
                                        return <div key={header.id} className="grid-header-cell" style={{ visibility: 'hidden' }} />;
                                    }
                                    
                                    const column = header.column;
                                    const canFilter = (column.columnDef as any).enableColumnFilter !== false;
                                    const filterValue = this.columnFilters[column.id] ?? "";
                                    
                                    const isPinnedLeft = column.getIsPinned() === 'left';
                                    const isPinnedRight = column.getIsPinned() === 'right';
                                    
                                    const pinnedStyle = isPinnedLeft 
                                        ? { left: `${column.getStart("left")}px`, position: 'sticky' as const, zIndex: 3 }
                                        : isPinnedRight
                                            ? { right: `${column.getAfter("right")}px`, position: 'sticky' as const, zIndex: 3 }
                                            : {};

                                    return (
                                        <div
                                            key={header.id}
                                            className="grid-header-cell floating-filter-cell"
                                            data-pinned={column.getIsPinned() || undefined}
                                            style={{
                                                gridColumn: header.colSpan > 1 ? `span ${header.colSpan}` : "auto",
                                                position: "relative" as const,
                                                ...pinnedStyle
                                            }}
                                        >
                                            {canFilter ? (
                                                <wsx-ac-filter-input
                                                    column={column}
                                                    value={filterValue}
                                                    onChange={(val: string) => this.setColumnFilter(column.id, val)}
                                                    variant="floating"
                                                />
                                            ) : null}
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>

                    {/* Body */}
                    <div
                        className="grid-body"
                        ref={(el: HTMLElement | null) => {
                            if (el) {
                                this.bodyScrollElement = el;
                                this.syncBodyScroll();
                            }
                        }}
                    >
                        <div style={{ height: `${paddingTop}px` }}></div>
                        {visibleRows.map((row) => (
                            <div
                                key={row.id}
                                className={`grid-row ${row.getIsGrouped() ? 'grid-row-grouped' : ''}`}
                                data-row-id={row.id}
                                data-selected={row.getIsSelected()}
                                onClick={() => {
                                    if (row.getIsGrouped()) {
                                        this.toggleGroup(row.id, !row.getIsExpanded());
                                    } else if (this._selectionConfigIsSet && this._selectionConfig?.enabled !== false && this._selectionConfig?.mode === 'single') {
                                        this.selectRow(row.id);
                                    }
                                }}
                            >
                                {row.getVisibleCells().map((cell) => {
                                    let rendered: any;
                                    
                                    if (cell.getIsGrouped()) {
                                        rendered = (
                                            <div className="grid-cell-group" style={{ paddingLeft: `${row.depth * 20}px` }}>
                                                <span className="grid-group-toggle" style={{ cursor: "pointer", marginRight: "8px" }}>
                                                    {row.getIsExpanded() ? '▼' : '▶'}
                                                </span>
                                                {flexRender(cell.column.columnDef.cell, cell.getContext())} ({row.subRows.length})
                                            </div>
                                        );
                                    } else if (cell.getIsAggregated()) {
                                        rendered = flexRender(
                                            cell.column.columnDef.aggregatedCell ?? cell.column.columnDef.cell,
                                            cell.getContext()
                                        );
                                    } else if (cell.getIsPlaceholder()) {
                                        rendered = null;
                                    } else {
                                        rendered = flexRender(
                                            cell.column.columnDef.cell,
                                            cell.getContext(),
                                        );
                                    }
                                    
                                    const column = cell.column;
                                    const isPinnedLeft = column.getIsPinned() === 'left';
                                    const isPinnedRight = column.getIsPinned() === 'right';
                                    const pinnedStyle = isPinnedLeft 
                                        ? { left: `${column.getStart("left")}px`, position: 'sticky' as const, zIndex: 2 }
                                        : isPinnedRight
                                            ? { right: `${column.getAfter("right")}px`, position: 'sticky' as const, zIndex: 2 }
                                            : {};

                                    const isEditing = this._editingConfigIsSet && this._editingConfig?.enabled !== false && 
                                                      this.editingState.rowId === row.id && 
                                                      this.editingState.columnId === column.id;

                                    return (
                                        <div
                                            key={cell.id}
                                            className="grid-cell"
                                            data-pinned={column.getIsPinned() || undefined}
                                            style={{ ...pinnedStyle }}
                                            onDoubleClick={() => {
                                                if (this._editingConfigIsSet && this._editingConfig?.enabled !== false && (column.columnDef as unknown as { enableEditing?: boolean }).enableEditing !== false) {
                                                    this.startEdit(row.id, column.id, cell.getValue());
                                                }
                                            }}
                                        >
                                            {isEditing ? (
                                                <wsx-ac-cell-editor
                                                    value={this.editingState.value}
                                                    type={(column.columnDef as any).filterType === 'number' ? 'number' : 'text'}
                                                    onSave={() => {
                                                        // HACK: Read value from DOM as event detail might vary
                                                        const editor = this.shadowRoot?.querySelector('wsx-ac-cell-editor') as any;
                                                        if (editor) this.saveEdit(editor.value);
                                                    }}
                                                    onCancel={() => this.cancelEdit()}
                                                />
                                            ) : (
                                                <div>{rendered}</div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        ))}
                        <div style={{ height: `${paddingBottom}px` }}></div>
                    </div>
                    {/* Pagination Controls */}
                    {this._paginationConfigIsSet && this._paginationConfig?.enabled !== false && (
                        <wsx-ac-pagination-controls
                            pageIndex={this.pagination.pageIndex}
                            pageSize={this.pagination.pageSize}
                            totalRows={(() => { const m = this.table.getFilteredRowModel(); return m && m.rows ? m.rows.length : 0; })()}
                            totalPages={this.table.getPageCount()}
                            pageSizeOptions={this._paginationConfig?.pageSizeOptions}
                            onPageChange={(page: number) => this.setPageIndex(page)}
                            onPageSizeChange={(size: number) => this.setPageSize(size)}
                        />
                    )}
                </div>
            </div>
        );
    }

    /**
     * 公共 API: 设置排序状态
     */
    public setSorting(sorting: SortingState): void {
        this.sorting = sorting;
        this.updateTable();
    }

    /**
     * 公共 API: 获取当前排序状态
     */
    public getSorting(): SortingState {
        return this.sorting;
    }

    /**
     * 公共 API: 重置排序状态
     */
    public resetSorting(): void {
        this.sorting = [];
        this.updateTable();
    }

    private notifyFilterChange(): void {
        if (
            this._filteringConfigIsSet &&
            this._filteringConfig?.onFilterChange
        ) {
            const filterState: FilterState = {
                globalFilter: this.globalFilter || undefined,
                columnFilters: { ...this.columnFilters },
            };
            this._filteringConfig.onFilterChange(filterState);
        }
    }

    /** RFC-0003: 设置全局过滤（供外部搜索框等调用） */
    public setGlobalFilter(value: string): void {
        this.globalFilter = value;
        this.notifyFilterChange();
        this.updateTable();
        this.updateVirtualization();
    }

    /** RFC-0003: 设置列过滤 */
    public setColumnFilter(columnId: string, value: string): void {
        if (value === "") {
            const next = { ...this.columnFilters };
            delete next[columnId];
            this.columnFilters = next;
        } else {
            this.columnFilters = {
                ...this.columnFilters,
                [columnId]: value,
            };
        }
        this.notifyFilterChange();
        this.updateTable();
        this.updateVirtualization();
        this.updateFilterMenuPortal();
    }

    /** RFC-0003: 清除所有过滤 */
    public clearFilters(): void {
        this.globalFilter = "";
        this.columnFilters = {};
        this.notifyFilterChange();
        this.updateTable();
        this.updateVirtualization();
        this.updateFilterMenuPortal();
    }

    /** RFC-0003: 获取当前过滤状态 */
    public getFilterState(): FilterState {
        return {
            globalFilter: this.globalFilter || undefined,
            columnFilters: { ...this.columnFilters },
        };
    }

    /**
     * 公共 API: 固定列
     */
    public pinColumn(columnId: string, position: 'left' | 'right' | false): void {
        const next = { ...this.columnPinning };
        // Remove from existing
        if (next.left) next.left = next.left.filter(id => id !== columnId);
        if (next.right) next.right = next.right.filter(id => id !== columnId);
        
        // Add to new
        if (position === 'left') {
            next.left = [...(next.left || []), columnId];
        } else if (position === 'right') {
            next.right = [...(next.right || []), columnId];
        }
        
        this.columnPinning = next;
        this._pinningConfig?.onPinningChange?.(next);
        this.updateTable();
    }

    /**
     * 公共 API: 取消固定列
     */
    public unpinColumn(columnId: string): void {
        this.pinColumn(columnId, false);
    }

    /**
     * 公共 API: 获取固定列
     */
    public getPinnedColumns(): ColumnPinningState {
        return {
            left: this.columnPinning.left || [],
            right: this.columnPinning.right || []
        };
    }

    // Editing Methods
    public startEdit(rowId: string, columnId: string, initialValue?: any) {
        if (!this._editingConfig?.enabled) return;
        
        // Find current value if not provided
        if (initialValue === undefined && this.table) {
            const row = this.table.getRow(rowId);
            if (row) {
                initialValue = row.getValue(columnId);
            }
        }

        this.editingState = { rowId, columnId, value: initialValue };
        this._editingConfig.onEditStart?.(rowId, columnId);
        this.updateTable();
    }

    public saveEdit(newValue: any) {
        const { rowId, columnId } = this.editingState;
        if (rowId && columnId) {
            this._editingConfig.onEditSave?.(rowId, columnId, newValue);
            // In a real app, data update happens via props change, but we clear edit state now
            this.cancelEdit(); 
        }
    }

    public cancelEdit() {
        const { rowId, columnId } = this.editingState;
        if (rowId && columnId) {
            this._editingConfig.onEditCancel?.(rowId, columnId);
        }
        this.editingState = { rowId: null, columnId: null, value: null };
        this.updateTable();
    }

    // Grouping Methods
    public setGrouping(columnIds: string[]) {
        this.grouping = columnIds;
        this._groupingConfig.onGroupingChange?.(columnIds);
        this.updateTable();
    }

    public toggleGroup(rowId: string, isExpanded?: boolean) {
        // With tanstack table, we toggle expanded state via table handler or state update
        // Here we update state directly for control
        if (typeof this.expanded === 'boolean') {
            this.expanded = { [rowId]: isExpanded !== undefined ? isExpanded : !this.expanded };
        } else {
            const next = { ...this.expanded };
            if (isExpanded !== undefined) {
                next[rowId] = isExpanded;
            } else {
                next[rowId] = !next[rowId];
            }
            this.expanded = next;
        }
        this.updateTable();
    }

    public expandAll() {
        this.expanded = true;
        this.updateTable();
    }

    public collapseAll() {
        this.expanded = {};
        this.updateTable();
    }

    /**
     * 同步表头水平滚动
     */
    private syncHeaderScroll(): void {
        if (!this.bodyScrollElement || !this.headerScrollElement) {
            return;
        }

        // 移除旧的事件监听器（如果存在）
        const oldHandler = (this.bodyScrollElement as any).__headerScrollHandler;
        if (oldHandler) {
            this.bodyScrollElement.removeEventListener("scroll", oldHandler);
        }

        // 监听内容区域滚动，同步表头
        this.bodyScrollElement.addEventListener("scroll", this.handleScroll);
        (this.bodyScrollElement as any).__headerScrollHandler = this.handleScroll;
    }

    /**
     * 同步内容区域水平滚动
     */
    private syncBodyScroll(): void {
        if (!this.bodyScrollElement || !this.headerScrollElement) {
            return;
        }

        // 移除旧的事件监听器（如果存在）
        const oldHandler = (this.headerScrollElement as any).__bodyScrollHandler;
        if (oldHandler) {
            this.headerScrollElement.removeEventListener("scroll", oldHandler);
        }

        // 监听表头滚动，同步内容区域
        const handler = () => {
            if (this.isSyncingScroll) {
                return;
            }
            this.isSyncingScroll = true;
            if (this.bodyScrollElement) {
                this.bodyScrollElement.scrollLeft =
                    this.headerScrollElement!.scrollLeft;
            }
            requestAnimationFrame(() => {
                this.isSyncingScroll = false;
            });
        };

        this.headerScrollElement.addEventListener("scroll", handler);
        (this.headerScrollElement as any).__bodyScrollHandler = handler;
    }
}

/**
 * 排序配置接口
 */
export interface GridSortingConfig {
    /**
     * 是否启用排序（默认：true）
     */
    enabled?: boolean;
    /**
     * 是否允许多列排序（默认：true）
     */
    multiColumn?: boolean;
    /**
     * 初始排序状态
     */
    initialState?: SortingState;
    /**
     * 排序状态变化回调
     */
    onSortingChange?: (sorting: SortingState) => void;
}
